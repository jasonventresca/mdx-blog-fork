---
id: "35492681-6782-4bc4-af63-ab66ef284728"
type: "blog"
author: "O Wolfson"
title: "Building a Content Management System for Static MDX Files"
date: "2024-06-04"
description: "In this article, we'll walk you through creating a content management system (CMS) for our MDX Blog, where blog posts are stored as local static files. We'll cover saving posts, generating a cache for efficient data retrieval, and handling form submissions for new blog entries."
categories:
  - Web Development
tags:
  - cache
  - mdx
  - blog
  - cms
image: "/images/default.jpg"
path: "building-a-content-management-system-for-static-mdx-files.mdx"
---

Let's create a content management system (CMS) for our MDX Blog, where blog posts are stored as local static files. We'll cover saving posts, generating a cache for efficient data retrieval, and handling form submissions for new blog entries.

Our CMS will:

1. Save blog posts as MDX files locally.
2. Regenerate a cache of posts to improve performance.
3. Handle form submissions for creating new posts.

### Why Caching?

Caching is crucial for enhancing performance and reducing the load on the file system. When dealing with static files, reading and parsing each file on every request can be inefficient, especially as the number of posts grows. By generating a cache, we can quickly access metadata and content without repeatedly accessing the file system.

### Components Involved

1. **MDX File Handling**: A function to save form data as MDX files.
2. **Cache Generation**: A script to create a cache of the posts.
3. **API Endpoint**: An endpoint to handle POST requests and save the files.
4. **Form Component**: A React component to capture user input for new blog posts.

### 1. Saving Form Data as MDX Files

We need a function to save the submitted form data as an MDX file. This function will:

- Format the data properly.
- Ensure unique filenames by checking for existing files.
- Regenerate the posts cache after saving the file.

Here's the `saveFileLocally` function:

```javascript
const fs = require("fs");
const path = require("path");
const { exec } = require("child_process");
const { generatePostsCache } = require("./posts-utils");

export function saveFileLocally(data) {
  console.log("Data received:", data.date);
  const { date, title, categories, tags, ...rest } = data;
  const projectRoot = process.cwd();

  let filename = `${title.toLowerCase().replace(/\s+/g, "-")}.mdx`;
  let slug = `${title.toLowerCase().replace(/\s+/g, "-")}`;
  let filePath = path.join(projectRoot, "data/posts", filename);

  let counter = 1;
  while (fs.existsSync(filePath)) {
    filename = `${title.toLowerCase().replace(/\s+/g, "-")}-${counter}.mdx`;
    filePath = path.join(projectRoot, "data/posts", filename);
    counter++;
  }

  const currentDate = new Date(data.date);
  const formattedDate = `${currentDate.getFullYear()}-${String(
    currentDate.getMonth() + 1
  ).padStart(2, "0")}-${String(currentDate.getDate()).padStart(2, "0")}`;

  const formattedCategories = categories.map((cat) => `  - ${cat}`).join("\n");
  const formattedTags = tags
    .split(", ")
    .map((tag) => `  - ${tag.trim()}`)
    .join("\n");

  let fileContent = `---
id: "${data.id}"
type: "${data.type}"
author: "${data.author}"
title: "${title}"
date: "${formattedDate}"
description: "${data.description}"
categories:
${formattedCategories}
tags:
${formattedTags}
image: "/images/default.jpg"
path: "${filename}"
---

${data.content}
`;

  fs.writeFile(filePath, fileContent, (err) => {
    if (err) {
      console.error("Error writing file:", err);
    } else {
      generatePostsCache();
      exec(`code "${filePath}"`, (error, stdout, stderr) => {
        if (error) {
          console.error(`exec error: ${error}`);
          return;
        }
        console.log(`stdout: ${stdout}`);
        console.error(`stderr: ${stderr}`);
      });
    }
  });

  return slug;
}
```

### 2. Generating the Cache

The cache script reads all MDX files, extracts the necessary metadata, and writes it to a JSON file. This cached data can then be quickly accessed, improving performance.

Here's the `cachePosts.js` script:

```javascript
import fs from "fs";
import path from "path";
import matter from "gray-matter";
import { notFound } from "next/navigation";
import { startOfDay, endOfDay } from "date-fns";

// Generate the cache
export function generatePostsCache() {
  const postsDirectory = path.join(process.cwd(), "data/posts");
  const fileNames = fs
    .readdirSync(postsDirectory)
    .filter(
      (fileName) => !fileName.startsWith(".") && fileName.endsWith(".mdx")
    );

  const currentDate = startOfDay(new Date()); // Get the start of the current day

  const posts = fileNames
    .map((fileName) => {
      const fullPath = path.join(postsDirectory, fileName);
      const fileContents = fs.readFileSync(fullPath, "utf8");
      const { data: frontMatter } = matter(fileContents);

      const postDate = startOfDay(new Date(frontMatter.date)); // Get the start of the post's date

      // Skip future-dated posts and include posts for the current day
      if (postDate > currentDate) {
        return null;
      }

      return {
        slug: fileName.replace(".mdx", ""),
        ...frontMatter,
      };
    })
    .filter(Boolean); // Filter out null values representing future-dated posts

  const cachePath = path.join(process.cwd(), "cache/posts.json");
  fs.writeFileSync(cachePath, JSON.stringify(posts, null, 2));

  return posts;
}
```

### 3. Handling POST Requests

We need an API endpoint to handle the POST requests from our form. This endpoint will call the `saveFileLocally` function and respond with the path of the saved file or an error message.

Here's the implementation of the POST handler:

```javascript
import { saveFileLocally } from "@/lib/save-file-locally";
import { generatePostsCache } from "@/lib/posts-utils.mjs";

export async function POST(req) {
  if (req.method === "POST") {
    try {
      const data = await req.json();
      const filePath = saveFileLocally(data);
      return new Response(JSON.stringify({ filePath }), {
        headers: { "content-type": "application/json" },
      });
    } catch (error) {
      console.error("Error:", error);
      return new Response(
        JSON.stringify({ message: "Error processing request" }),
        {
          status: 500,
          headers: { "content-type": "application/json" },
        }
      );
    }
  } else {
    return new Response(
      JSON.stringify({ message: "Only POST requests are accepted" }),
      {
        headers: { "content-type": "application/json" },
      }
    );
  }
}
```

### 4. Creating the Form Component

Finally, we need a form component that captures the user's input and sends it to our API endpoint. We'll use `react-hook-form` for form handling and validation, and `zod` for schema validation.

Here's the `CreatePostForm` component:

```jsx
"use client";

import React, { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { v4 as uuidv4 } from "uuid";
import { useRouter } from "next/navigation";

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import DatePickerField from "@/components/date-picker";
import { MultiSelect } from "@/components/rs-multi-select";

const formSchema = z.object({
  date: z.date(),
  type: z.string().optional(),
  title: z.string().min(3, { message: "Title must be at least 3 characters." }),
  description: z
    .string()
    .min(15, { message: "Description must be at least 15 characters." }),
  content: z
    .string()
    .min(2, { message: "Content must be at least 2 characters." }),
  categories: z.array(z.string()).nonempty(),
  tags: z.string().optional(),
});

export function CreatePostForm() {
  const [selectedValue, setSelectedValue] = useState("blog");
  const form = useForm({
    resolver: zodResolver(formSchema),
    defaultValues: {
      date: new Date(),
      type: "blog",
      title: "",
      description: "",
      content: "",
      categories: ["Web Development"],
      tags: "",
    },
  });
  const authorName = "O Wolfson";
  const router = useRouter();

  async function onSubmit(values) {
    const endpoint = "/api/save-file-locally";
    const submissionData = { ...values, author: authorName, id: uuidv4() };

    try {
      const response = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(submissionData),
      });
      if (!response.ok) throw new Error("Network response was not ok");
      const result = await response.json();
      console.log("Success:", result);
      form.reset();
      router.push(`/blog/${result.filePath}`);
    } catch (error) {
      console.error("Error:", error);
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <Form
          Field
          control={form.control}
          name="type"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Post Type</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger className="w-[180px]">
                    <SelectValue placeholder="Select post type" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="blog">Blog</SelectItem>
                  <SelectItem value="project">Project</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="date"
          render={({ field }) => (
            <FormItem className="flex flex-col">
              <FormLabel className="font-semibold text-md">Date</FormLabel>
              <DatePickerField field={field} />
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Post Title</FormLabel>
              <FormControl>
                <Input placeholder="Title" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea placeholder="Description" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="content"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Content</FormLabel>
              <FormControl>
                <Textarea
                  id="content"
                  className="h-[300px]"
                  placeholder="Content"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="categories"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Categories</FormLabel>
              <FormControl>
                <MultiSelect
                  selectedCategories={field.value}
                  setSelectedCategories={field.onChange}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="tags"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Tags</FormLabel>
              <FormControl>
                <Input placeholder="Enter tags (comma separated)" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit">Create</Button>
      </form>
    </Form>
  );
}
```

### Conclusion

By following these steps, we've built a robust content management system for our MDX Blog. Users can submit new blog posts through a form, which are then saved as MDX files on the server. The posts cache is regenerated to ensure quick access to the latest posts, enhancing performance. This setup leverages the power of Next.js, MDX, and React to create a seamless and dynamic content creation experience.

We hope this guide helps you understand the process and encourages you to build similar systems for your projects. Happy coding!
