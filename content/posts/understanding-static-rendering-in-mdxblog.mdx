export const metadata = {
  id: "8LmHMHf41SyPgCyah7RXMa",
  type: "blog",
  title: "Understanding Static Rendering in MDXBlog",
  author: "O Wolfson",
  publishDate: "2024-08-31",
  description:
    "Static rendering is a powerful feature of Next.js that allows you to pre-generate HTML pages at build time.",
  categories: ["Web Development"],
  tags: ["mdx", "static", "blog", "rendering"],
  modifiedDate: "2024-08-31T01:52:46.815Z",
  image: null,
  draft: false,
  relatedPosts: [""],
};

Static rendering is a powerful feature of Next.js that allows you to pre-generate HTML pages at build time. This approach enhances performance, improves SEO, and reduces server load by serving pre-rendered content instead of dynamically generating it on every request. In this article, we’ll explore how static rendering works in **MDXBlog**.

## Introduction to Static Rendering

Static rendering, also known as Static Site Generation (SSG), is the process where HTML pages are generated at build time and served as static files. In MDXBlog, this is achieved through a combination of Next.js’s static generation capabilities and the integration of MDX files, which allow for rich, interactive content.

## How MDX is Integrated into MDXBlog

**MDXBlog** uses the `@next/mdx` plugin to seamlessly integrate MDX files into the Next.js build process. MDX allows you to write JSX within Markdown, enabling the use of React components in your content. The following configuration in `next.config.mjs` shows how MDX is set up:

```javascript
import createMDX from "@next/mdx";
import remarkGfm from "remark-gfm";
import remarkFrontmatter from "remark-frontmatter";
import rehypeHighlight from "rehype-highlight";

const nextConfig = {
  pageExtensions: ["js", "jsx", "md", "mdx", "ts", "tsx"],
};

const withMDX = createMDX({
  options: {
    remarkPlugins: [remarkGfm, remarkFrontmatter],
    rehypePlugins: [rehypeHighlight],
    format: "mdx",
  },
});

export default withMDX(nextConfig);
```

This configuration allows MDX files to be treated as standard Next.js pages or components. It also enables the use of plugins like `remarkGfm` and `rehypeHighlight` to extend the capabilities of your Markdown content.

## Understanding the Build Process

During the build process, Next.js compiles your MDX files into React components. These components are then rendered into static HTML files, which are served to users when they request a page.

### Dynamic Imports and Static Rendering

The `MdxContent` component uses a dynamic import to load MDX files based on a slug, and Next.js resolves these imports at build time for pre-defined pages. Here’s how it works:

- **Dynamic Import:** The `MdxContent` component dynamically imports the MDX content based on the provided `slug`.

  ```javascript
  const MDXContent = require(`@/content/pages/${slug}.mdx`).default;
  ```

- **Build-Time Resolution:** During the build, Next.js resolves these dynamic imports, rendering the MDX content into static HTML. This means that when the site is deployed, users receive pre-rendered HTML, ensuring fast load times and a smooth experience.

## Exploring the Key Components

### MDX Content Component

The `MdxContent` component is crucial in dynamically rendering MDX content. Despite being a client-side component (as indicated by `"use client"`), it participates in the static generation process:

```javascript
"use client";

import React from "react";
import { useRouter } from "next/navigation";

type MdxContentProps = {
  slug: string,
};

const MdxContent = ({ slug }: MdxContentProps) => {
  const router = useRouter();

  try {
    const MDXContent = require(`@/content/pages/${slug}.mdx`).default;

    return (
      <div>
        <MDXContent />
      </div>
    );
  } catch (error) {
    console.error("Failed to load MDX content:", error);
    router.replace("/404");
    return <p>Content not found.</p>;
  }
};

export default MdxContent;
```

### Custom MDX Components

Your `mdx-components.tsx` file customizes how different HTML elements and components are rendered within MDX content. This customization ensures that your content is styled consistently and utilizes the power of React components:

```javascript
export function useMDXComponents(components: MDXComponents): MDXComponents {
  return {
    ...components,
    YouTube,
    Image,
    pre: Pre,
    code: (props) => {
      const { className, children } = props;
      if (className) {
        return <Code {...props} />;
      }
      return <InlineCode>{children}</InlineCode>;
    },
    h1: (props) => (
      <h1 className="text-4xl font-black pb-4 w-full" {...props} />
    ),
    h2: (props) => <h2 className="text-3xl font-bold pb-4 w-full" {...props} />,
    h3: (props) => (
      <h3 className="text-2xl font-semibold pb-4 w-full" {...props} />
    ),
    h4: (props) => (
      <h4 className="text-xl font-medium pb-4 w-full" {...props} />
    ),
    h5: (props) => (
      <h5 className="text-lg font-normal pb-4 w-full" {...props} />
    ),
    h6: (props) => (
      <h6 className="text-base font-light pb-4 w-full" {...props} />
    ),
    p: (props) => <p className="text-lg mb-4 w-full" {...props} />,
    li: (props) => <li className="pb-1" {...props} />,
    ul: (props) => <ul className="list-disc pl-6 pb-4 w-full" {...props} />,
    ol: (props) => <ol className="list-decimal pl-6 pb-4 w-full" {...props} />,
    hr: (props) => <hr className="my-4" {...props} />,
    blockquote: (props) => (
      <blockquote
        style={{ paddingBottom: 0 }}
        className="border-l-4 pl-4 my-4"
        {...props}
      />
    ),
    a: (props) => <a className="hover:underline font-semibold" {...props} />,
  };
}
```

These custom components are applied during the MDX compilation process, ensuring that when the content is rendered, it adheres to your design and functionality specifications.

## The Role of `generateMetadata`

In a page component, the `generateMetadata` function plays a critical role in extracting and setting metadata from the MDX file:

```javascript
export async function generateMetadata(): Promise<Metadata> {
  const filePath = path.join(process.cwd(), "content/pages/about.mdx");
  const fileContent = fs.readFileSync(filePath, "utf8");

  const metadataMatch = fileContent.match(
    /export\s+const\s+metadata\s+=\s+({[\s\S]*?});/
  );

  if (metadataMatch?.[1]) {
    const metadata = eval(`(${metadataMatch[1]})`);
    return {
      title: metadata.title,
      description: metadata.description,
    };
  }
  throw new Error("Metadata not found in the MDX file.");
}
```

This function ensures that the correct metadata, such as the title and description, is included in the pre-rendered HTML, which is essential for SEO and user experience.

## Why Static Rendering Matters

Static rendering offers several benefits:

- **Performance:** Pre-rendered pages load faster because they don’t need to be generated on the fly.
- **SEO:** Search engines can easily index static pages, improving your site’s visibility.
- **Scalability:** Serving static content reduces server load, making it easier to handle large volumes of traffic.

In MDXBlog, static rendering combines with the dynamic capabilities of React and MDX, providing a powerful platform that balances flexibility with performance.

## Conclusion

In MDXBlog, static rendering is achieved through a combination of MDX processing, dynamic imports resolved at build time, and custom component rendering. This approach ensures that your content is served as fast, SEO-friendly static pages while retaining the flexibility and interactivity of modern React applications.

By understanding how static rendering works in MDXBlog, you can better optimize your content delivery and ensure a seamless user experience across all pages. Whether you're creating new content or extending the functionality of a blog, this static-first approach will serve as a solid foundation for future growth.
